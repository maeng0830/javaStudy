package java_review_zb;

public class JavaReviewZb1_2 {
    public static void main(String[] args) {
        int i1 = 0b0000_0000_0000_0000_0000_0000_0000_1100; // 2진수 12
        int i2 = 0b1000_0000_0000_0000_0000_0000_0000_1100; // 부호비트 변경(-)

        System.out.println(i1); // 12
        System.out.println(i2); // -2147483636, 부호비트만 변경해줬는데 전혀 다른 값이 산출
        System.out.println(i1 + i2); // -2147483624

        // 부호 비르를 변경하는 것이 아닌, 어떤 2진수 값에 어떤 값을 더하면 0이 될까를 생각하게 됨.
        // 그래서 2진수 A가 0이 되게 하는 값을 2진수 -A라고 상정하자.
        int i3 = 0b0000_0000_0000_0000_0000_0000_0000_1100; // 2진수 12
        int i4 = 0b1111_1111_1111_1111_1111_1111_1111_0100; // 2진수 12에 더했을 때, 0이 산출되게 하는 수
        int i5 = 0b0000_0000_0000_0000_0000_0000_0000_0000; // i5 = i3 + i4 = 0, i4는 i3이 0이 되게 하므로 2진수 -12라고 할 수 있지 않을까?

        System.out.println(i3);
        System.out.println(i4);
        System.out.println(i5);
        System.out.println(i3+i4);

        // 2진수 A가 0이 되게 하는 수를 통해, 2진수 -A를 나타낼 수 있다.
        // 그리고 이처럼 특정 2진수 A를 0이 되게 하는 수를 2진수 A에 대한 '2의 보수'라고 한다.
        // 2의 보수는 어떻게 구할 수 있을까?

        int i6 = 0b0000_0000_0000_0000_0000_0000_0000_1100; // 2진수 12
        int i7 = 0b1111_1111_1111_1111_1111_1111_1111_0011; // 2진수 12의 '1의 보수', 1의 보수 = 특정 2진수 A와 정반대의 비트를 가진 수를 말한다.
        int i8 = 0b1111_1111_1111_1111_1111_1111_1111_0100; // 2진수 12의 '2의 보수', 2의 보수 = 특정 2진수 A의 1의 보수 + 1
    }
}
